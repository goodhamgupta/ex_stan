<!-- livebook:{"persist_outputs":true} -->

# ExStan: Linear Regression

```elixir
Mix.install([
  {:ex_stan, path: "~/shubham/ex_stan"},
  {:explorer, "~> 0.8.0"},
  {:kino_explorer, "~> 0.1.18"},
  {:vega_lite, "~> 0.1.6"},
  {:kino_vega_lite, "~> 0.1.10"}
])
```

## Introduction

```elixir
alias ExStan.{Model, Fit}
require Explorer.DataFrame, as: DF
alias VegaLite, as: Vl
```

### Dataset

<!-- livebook:{"break_markdown":true} -->

The simplest linear regression model has a single predictor and a slope and intercept coefficient, and normally distributed noise. This model can be written using standard regression notation as

$$
y_n = \alpha + \Beta x_n + \epsilon_n, \text{ where } \epsilon_n \sim normal(0, \sigma) \\
$$
This is equivalent to the following sampling involving the residual,

$$
y_n - (\alpha + \beta X_n) \sim normal(0, \sigma) \\
$$
and reducing still further, to

$$
y_n = normal(\alpha + \beta X_n, \sigma)
$$

```elixir
defmodule StanModelData do
  def generate_data(n) do
    seed = 5000
    key = Nx.Random.key(seed)

    # Sample alpha and beta from a normal distribution
    {alpha, key} = Nx.Random.normal(key, 0, 1)
    {beta, key} = Nx.Random.normal(key, 0, 1)

    # Assume sigma is sampled from a uniform distribution between 0 and 2
    {sigma, key} = Nx.Random.uniform(key, 0, 2)

    # Generate vector x from a normal distribution
    {x, key} = Nx.Random.normal(key, 0, 1, shape: {n})

    # Calculate y based on the model y ~ normal(alpha + beta * x, sigma)
    first = Nx.add(alpha, Nx.multiply(beta, x))
    {second, _key} = Nx.Random.normal(key, 0, sigma, shape: {n})
    y = Nx.add(first, second)
    # Return the generated data and parameters
    {x, y, alpha, beta, sigma}
  end
end

# Generate data for N = 100
n = 100
{x, y, alpha, beta, sigma} = StanModelData.generate_data(n)

IO.puts("alpha: #{Nx.to_number(alpha)}")
IO.puts("beta: #{Nx.to_number(beta)}")
IO.puts("sigma: #{Nx.to_number(sigma)}")
IO.puts("Number of x samples: #{Nx.size(x)}")
IO.puts("Number of y samples: #{Nx.size(y)}")
```

```elixir
Vl.new(width: 400, height: 300, title: "Sample Dataset")
|> Vl.data_from_values(x: Nx.to_list(x), y: Nx.to_list(y))
|> Vl.encode_field(:x, "x", type: :quantitative)
|> Vl.encode_field(:y, "y", type: :quantitative)
|> Vl.layers([
  Vl.new()
  |> Vl.mark(:point)
  |> Vl.encode_field(:y, "y", type: :quantitative)
])
```

### Initialize Model Parameters

```elixir
data = %{
  N: x |> Nx.size(),
  x: x |> Nx.to_list(),
  y: y |> Nx.to_list()
}
```

```elixir
model_code = ~S"""
data {
  int<lower=0> N;
  vector[N] x;
  vector[N] y;
}
parameters {
  real alpha;
  real beta;
  real<lower=0> sigma;
}
model {
  y ~ normal(alpha + beta * x, sigma);
}
"""
```

### Build Model

```elixir
model = ExStan.build(model_code, data)
```

### Sample from Model

```elixir
fit = Model.sample(model, num_chains: 4, num_warmup: 1000, num_samples: 2000)
```

### Evaluate

```elixir
fit.param_names
```

```elixir
df = Fit.to_frame(fit)
```

```elixir
df
|> DF.select(fit.param_names)
|> DF.describe(percentiles: [0.025, 0.25, 0.5, 0.75, 0.975])
```

### Plot Results

```elixir
tmp = DF.select(df, fit.param_names) |> DF.to_rows()

new_list =
  Enum.flat_map(tmp, fn map ->
    Enum.map(map, fn {key, value} ->
      %{
        "param_name" => key,
        "param_value" => value
      }
    end)
  end)

Vl.new(width: 400, height: 300)
|> Vl.data_from_values(new_list)
|> Vl.encode_field(:y, "param_name", type: :ordinal, title: "Parameter Name")
|> Vl.layers([
  Vl.new()
  |> Vl.mark(:point, filled: true)
  |> Vl.encode_field(:x, "param_value",
    aggregate: :mean,
    type: :quantitative,
    scale: [zero: false],
    title: "value"
  )
  |> Vl.encode(:color, value: :black),
  Vl.new()
  |> Vl.mark(:errorbar, extent: :stdev)
  |> Vl.encode_field(:x, "param_value", type: :quantitative, title: "Parameter Value")
])
```

```elixir
predicted_alpha =
  df
  |> DF.select(["alpha"])
  |> DF.to_series()
  |> Map.get("alpha")

predicted_beta =
  df
  |> DF.select(["beta"])
  |> DF.to_series()
  |> Map.get("beta")

predicted_sigma =
  df
  |> DF.select(["sigma"])
  |> DF.to_series()
  |> Map.get("sigma")
```

```elixir
key = Nx.Random.key(42)

alpha_mean =
  df
  |> DF.select(["alpha"])
  |> DF.to_series()
  |> Map.get("alpha")
  |> Explorer.Series.mean()

beta_mean =
  df
  |> DF.select(["beta"])
  |> DF.to_series()
  |> Map.get("beta")
  |> Explorer.Series.mean()

sigma_mean =
  df
  |> DF.select(["sigma"])
  |> DF.to_series()
  |> Map.get("sigma")
  |> Explorer.Series.mean()

first = Nx.multiply(beta_mean, x) |> Nx.add(alpha_mean)
{noise, _key} = Nx.Random.normal(key, 0, sigma_mean, shape: {Nx.size(x)})
predicted = first

x_list = Nx.to_list(x)
y_list = Nx.to_list(y)
predicted_list = Nx.to_list(predicted)
noise_list = Nx.to_list(noise)

result =
  DF.new(x: x_list, y: y_list, predicted: predicted_list, noise: noise_list) |> DF.to_rows()
```

```elixir
Vl.new(width: 400, height: 300, title: "Linear Regression Plot")
|> Vl.data_from_values(result)
|> Vl.encode_field(:x, "x", type: :quantitative)
|> Vl.layers([
  Vl.new()
  |> Vl.mark(:point)
  |> Vl.encode_field(:y, "y", type: :quantitative),
  Vl.new()
  |> Vl.mark(:errorband, extent: :ci)
  |> Vl.encode_field(:y, "predicted", type: :quantitative, title: "Predicted "),
  Vl.new()
  |> Vl.mark(:line)
  |> Vl.encode_field(:y, "predicted", type: :quantitative, aggregate: :mean)
  |> Vl.encode_field(:x, "x", type: :quantitative)
])
```
